# Development Notes: Hardware-First Architecture

## Core Architectural Principles

### 1. Atomic Component Independence
- Each component (buttons, indicators, etc.) should be self-contained
- Components handle their own:
  - Initialization
  - Self-testing
  - State management
  - Event handling
- This mirrors real hardware where each physical component has its own controller/microcontroller

### 2. Block Components (Simulation Only)
- Block components exist ONLY for simulation purposes
- They should ONLY handle:
  - Component positioning
  - Layout management
- No business logic
- No state management
- No event handling
- Think of them as the "virtual breadboard"

### 3. Event-Driven Communication
- Use event bus for ALL component communication
- This simulates physical bus communication (SPI, I2C, etc.)
- Components publish/subscribe to events
- No direct component-to-component communication
- No prop drilling
- No imperative logic

### 4. Hardware-First Mindset
When writing code, always consider:
- How would this work as a physical component?
- What would the hardware initialization sequence look like?
- How would this communicate on a real bus?
- What would the physical self-test look like?
- How would this handle hardware failures?

### 5. Encapsulation
- Each component should be a black box
- Internal state and behavior should be hidden
- External interface should be event-based
- No shared state between components
- No global state (except simulation necessities)

## Implementation Guidelines

### Component Structure
```typescript
// Example component structure
const Component = ({ id, position }) => {
  // 1. Self-contained state
  const [state, setState] = useState();
  
  // 2. Self-initialization
  useEffect(() => {
    initRegistry.acknowledge(id);
    // Component-specific init
  }, [id]);
  
  // 3. Self-testing
  useEffect(() => {
    // Component-specific test sequence
  }, []);
  
  // 4. Event handling
  useEffect(() => {
    const handler = (event) => {
      // Handle events as if they were hardware signals
    };
    return eventBus.subscribe(handler);
  }, []);
  
  // 5. Render
  return <div>...</div>;
};
```

### Block Structure
```typescript
// Example block structure
const Block = () => {
  // ONLY handle layout
  return (
    <div>
      <Component id="comp1" position={[x1, y1]} />
      <Component id="comp2" position={[x2, y2]} />
    </div>
  );
};
```

## Future Hardware Considerations

### Physical Implementation
- Each component would have:
  - Dedicated microcontroller
  - Physical bus interface
  - Hardware initialization sequence
  - Physical self-test capabilities
  - Error handling for hardware failures

### Communication Protocol
- Event bus simulates:
  - SPI/I2C bus communication
  - Hardware interrupts
  - Component status reporting
  - Error reporting

### Testing
- Self-test sequences should mirror physical component tests
- Error conditions should reflect hardware failure modes
- Initialization should match hardware startup sequence 