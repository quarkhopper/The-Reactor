# Development Notes: Slider Controls and Event Bus Integration

## Goal
Set up the slider controls (`SliderControl.tsx`) to communicate with the core system (`coreSystem.ts`) via the event bus. This will allow the sliders to dynamically update the `controlRodPositions` array in the core system.

---

## Steps to Implement

### 1. Emit Events from `SliderControl`
Modify `SliderControl.tsx` to emit `slider-change` events on the event bus whenever the slider value changes. Use the `rodIndex` and `value` to identify which control rod is being updated and its new position.

**Code to Add in `SliderControl.tsx`:**

```typescript
if (onChange) {
  onChange(phase, rodIndex); // Existing callback
}

// Emit event on the event bus
eventBus.publish('slider-change', { rodIndex, value: phase });
```

---

### 2. Subscribe to Events in `coreSystem.ts`
Add an event listener in `coreSystem.ts` to listen for `slider-change` events. Update the `controlRodPositions` array based on the `rodIndex` and `value` from the event.

**Code to Add in `coreSystem.ts`:**

```typescript
// Subscribe to slider change events
eventBus.subscribe('slider-change', (event: { rodIndex: number; value: number }) => {
  const { rodIndex, value } = event;

  if (rodIndex >= 0 && rodIndex < controlRodPositions.length) {
    controlRodPositions[rodIndex] = value; // Update the control rod position
    console.log(`[coreSystem] Control rod ${rodIndex} position updated to ${value}`);
  }
});
```

---

### 3. Test the Integration
Move the sliders in the UI and verify that the `controlRodPositions` array in `coreSystem.ts` is updated dynamically. Add temporary logging to confirm that the `slider-change` events are being emitted and received correctly.

**Test Steps:**
- Move a slider and check the console for logs like:
[coreSystem] Control rod 0 position updated to 0.5
---

### 4. Verify `tick` Function Behavior
Ensure that the `tick` function in `coreSystem.ts` uses the updated `controlRodPositions` values to calculate `controlInterference`.

**Key Code in `tick`:**

```typescript
controlInterference += (1 - controlRodPositions[i]) * influence * INTERFERENCE_SCALING_FACTOR;
```

---

## Long-Term Considerations
- **Abstract Event Bus Logic**:
- Consider creating a wrapper around the event bus to simplify testing and eventual hardware integration.
- **Prepare for Physical Components**:
- Ensure the event bus logic can be replaced with hardware-specific communication protocols when porting to physical devices.

---

## Checklist
- [x] Add event emission logic to `SliderControl.tsx`.
- [x] Add event listener in `coreSystem.ts` to update `controlRodPositions`.
- [ ] Test the slider-to-core-system communication.
- [ ] Verify that the `tick` function reflects the updated control rod positions.
- [ ] Remove any temporary logging after confirming functionality.

# Development Note: April 1, 2025

## What We Just Did

We've implemented a more centralized architecture for the reactor control system by:

1. Creating a central component manifest (`componentManifest.ts`) that serves as the single source of truth for all component IDs
2. Implementing a state transition manager (`stateTransitionManager.ts`) that centralizes all state transitions
3. Updating various handlers to use these centralized systems instead of duplicating logic

## Key Changes

### Component Manifest

- Created a central manifest file that categorizes all components by type
- Implemented helper functions to retrieve component IDs by category or all at once
- Added metadata support for components to track additional properties

### State Transition Manager

- Defined a clear state transition map showing the valid flow between states
- Implemented state transition handlers for each state
- Added validation to ensure only valid state transitions are allowed
- Centralized timing for state transitions

### Updated Components

- Modified `registry.ts` to use the state transition manager
- Updated `masterPower.ts` to use the state transition manager
- Updated `testSequence.ts` to use the state transition manager
- Enhanced `StateMachine.ts` to validate state transitions

## Benefits

1. **Single Source of Truth**: Component IDs are now defined in only one place, making it easier to add or remove components
2. **Centralized State Management**: State transitions are now managed in one place, making the flow easier to understand and modify
3. **Improved Validation**: State transitions are now validated to ensure they follow the expected flow
4. **Better Maintainability**: Changes to the component list or state flow only need to be made in one place

## Code Cleanup

As part of our refactoring, we've removed several redundant files that are no longer needed with our new architecture:

1. **initManifest.ts** - Replaced by our new componentManifest.ts
2. **testRegistry.ts** - Functionality now handled by our new testSequence.ts handler
3. **testSequence.ts** (in root state directory) - Replaced by our new testSequence.ts handler in the handlers directory

We've also updated the registry.ts file to use our new componentManifest.ts instead of the old initManifest.ts.

## Self-Test Improvements

We've fixed several issues with the self-test functionality:

1. **Fixed VerticalMeter and ConditionLight components**:
   - Updated both components to properly handle test mode by using the displayColor from the useTestable hook
   - Added logic to set appropriate values during test mode based on the test sequence colors

2. **Fixed indicator lights staying on after self-test**:
   - Updated the useTestable hook to ensure components properly reset to 'off' after the test sequence
   - Added additional state change handlers to reset components when entering startup or on state

3. **Improved test sequence performance**:
   - Modified the stateTransitionManager to run tests in parallel instead of serially
   - Removed the staggered delay that was causing tests to run one after another

These changes ensure that all components properly participate in the self-test sequence and correctly reset afterward, providing a more consistent and reliable testing experience.

## Additional Self-Test Improvements

We've made further improvements to the self-test functionality to address specific component behaviors:

1. **Digital Display Self-Test**:
   - Updated the DigitalDisplay component to count up from 00 to 99 during test mode
   - Added an interval that cycles through values every 50ms
   - Ensured the display properly resets after the test sequence

2. **Slider Control Self-Test**:
   - Added animation to the SliderControl component during test mode
   - Implemented a smooth up-and-down motion for the slider knobs
   - Fixed the rod_position_update command to match the correct type

3. **Indicator Light Reset**:
   - Enhanced the useTestable hook to ensure indicator lights properly reset after the test sequence
   - Added a handler for test_result events to reset components with a small delay
   - This ensures the last color in the test sequence is visible before resetting

These improvements provide a more comprehensive and visually appealing self-test sequence, ensuring all components are properly tested and reset afterward.

## Next Steps

1. Update any remaining components that might still be using hardcoded component IDs
2. Consider adding more metadata to components to support additional features
3. Implement visualization tools to help understand the state transition flow
4. Add more comprehensive logging for state transitions to aid in debugging

## Notes

This refactoring significantly improves the architecture of the system by reducing duplication and centralizing critical information. The component manifest and state transition manager now serve as the foundation for the entire system, making it more maintainable and extensible.