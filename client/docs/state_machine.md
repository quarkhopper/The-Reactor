# State Machine Documentation

## Core Principles

### Single Command Pathway
- All system communication flows through a single command pathway, analogous to an SPI bus
- The power button is a special case that controls the physical power state of the system
- No commands can be emitted before the system is powered on
- State changes are communicated through the same command pathway as all other system events

### Event Handling Best Practices
- **Avoid Emitting Events in Event Handlers**: When handling an event, avoid emitting the same type of event back to the state machine. This can create infinite loops and stack overflows.
  ```typescript
  // ❌ DON'T: This creates an infinite loop
  stateMachine.subscribe((cmd: Command) => {
    if (cmd.type === 'some_event') {
      stateMachine.emit(cmd); // Emitting same event type
    }
  });

  // ✅ DO: Just handle the event
  stateMachine.subscribe((cmd: Command) => {
    if (cmd.type === 'some_event') {
      // Handle the event without re-emitting
    }
  });
  ```

### Component ID Naming Conventions
- **Be Consistent with ID Formats**: Different components have specific ID formats that must be followed:
  - Control Rods: `control_rod_X` (where X is the rod index)
  - Fuel Rods: `fuel_rod_button_X_Y` (where X,Y are grid coordinates)
  - Load Banks: `load_bank_X` (where X is the bank index)
  - Cooling Loops: `loop_efficiency_X` (where X is the loop index)

### State Updates
- **Minimize State Updates**: Only update state when necessary and avoid redundant updates
- **Batch Related Updates**: When multiple related values change, consider batching them into a single state update
- **Validate State Changes**: Always validate incoming state changes before applying them

### Debugging Tips
- **Use Targeted Logging**: When debugging, add specific, one-time logs for state changes rather than per-tick logging
- **Log State Transitions**: Log state transitions with clear before/after values
- **Validate Event Flow**: When debugging event handling, log both the receipt and handling of events 

## Core System and UI Component Relationships

### Master-Slave Pattern
The core systems are the source of truth for all state, while UI components are slaves that reflect that state. This pattern is crucial for maintaining consistency and proper system behavior.

#### Example: Fuel Rod System
1. **Core System (Master)**:
   - Maintains the true state of each fuel rod (engaged/withdrawn/transitioning)
   - Controls timing of state transitions
   - Determines when reactivity calculations need updating
   - Emits state change events through the command pathway

2. **UI Component (Slave)**:
   - Sends simple action events through the command pathway
   - Listens for state change events from core
   - Updates visual representation based on core's state
   - Never maintains its own state about system behavior

#### Event Flow Example
```typescript
// UI Component (FuelRodButton.tsx)
const handleClick = () => {
  // Simple action event through command pathway
  stateMachine.emit({
    type: 'fuel_rod_toggle',
    id: `fuel_rod_button_${x}_${y}`
  });
};

// Core System (coreSystem.ts)
stateMachine.subscribe((cmd: Command) => {
  if (cmd.type === 'fuel_rod_toggle') {
    // Core determines new state and timing
    const newState = determineNewState(cmd.id);
    // Core emits state change through command pathway
    stateMachine.emit({
      type: 'fuel_rod_state_change',
      id: cmd.id,
      state: newState
    });
  }
});

// UI Component (FuelRodButton.tsx)
useEffect(() => {
  stateMachine.subscribe((cmd: Command) => {
    if (cmd.type === 'fuel_rod_state_change' && cmd.id === `fuel_rod_button_${x}_${y}`) {
      // Simply reflect core's state
      switch(cmd.state) {
        case 'transitioning': startBlinking(); break;
        case 'engaged': showTemperature(); break;
        case 'withdrawn': showOffState(); break;
      }
    }
  });
}, [x, y]);
```

#### Key Principles
1. **Single Source of Truth**: Core systems maintain all system state
2. **Unidirectional Flow**: 
   - UI -> Core: Simple action events through command pathway
   - Core -> UI: State change events through command pathway
3. **UI Responsibility**: 
   - Send user actions through command pathway
   - Reflect core state
   - Handle visual transitions
4. **Core Responsibility**:
   - Maintain system state
   - Control timing
   - Calculate system impacts
   - Emit state changes through command pathway

## Hardware Portability

### Physical Component Integration
The system is designed to closely align with a physical system using an SPI bus. All communication flows through a single command pathway, just as all communication in a physical system would flow through the SPI bus.

#### Input Sources
The same action events can be generated by multiple input sources, all flowing through the command pathway:
```typescript
// UI Button
const handleUiClick = (x: number, y: number) => {
  stateMachine.emit({
    type: 'fuel_rod_toggle',
    id: `fuel_rod_button_${x}_${y}`
  });
};

// Physical Button
const handlePhysicalButton = (x: number, y: number) => {
  stateMachine.emit({
    type: 'fuel_rod_toggle',
    id: `fuel_rod_button_${x}_${y}`
  });
};

// SPI Message
const handleSpiMessage = (message: SpiMessage) => {
  if (message.type === 'BUTTON_PRESS') {
    stateMachine.emit({
      type: 'fuel_rod_toggle',
      id: `fuel_rod_button_${message.x}_${message.y}`
    });
  }
};
```

### Hardware Interface Considerations

1. **Timing and Latency**:
   - Physical components may have different response times
   - Core systems should handle timing variations gracefully
   - Consider buffering for hardware communication delays

2. **Error Handling**:
   - Hardware failures should be reported but not crash the system
   - Implement fallback behaviors for hardware unavailability
   - Log hardware-specific errors separately from system errors

3. **State Synchronization**:
   - Physical components may need periodic state updates
   - Consider heartbeat mechanisms for hardware health checks
   - Implement state recovery procedures for hardware resets

### Best Practices for Hardware Integration

1. **Abstraction Layers**:
   - Keep hardware-specific code in dedicated modules
   - Use interfaces to abstract hardware details
   - Implement hardware simulators for testing

2. **Event Buffering**:
   - Buffer hardware events to handle communication delays
   - Implement priority queues for critical updates
   - Consider hardware-specific timing requirements

3. **State Management**:
   - Maintain hardware state separately from system state
   - Implement hardware state recovery procedures
   - Log hardware state changes for debugging

4. **Testing**:
   - Create hardware simulators for development
   - Implement hardware-in-the-loop testing
   - Test failure modes and recovery procedures

This architecture ensures that the system can be easily adapted to work with physical components while maintaining the same core behavior and state management. 

## Process Completion and State Transitions

### Process Completion Flow
1. **Component Acknowledgment**:
   - Components acknowledge process commands (init/test/shutdown)
   - Components NEVER emit process_complete events
   - Use registry.acknowledge() for process acknowledgments

2. **Manager Responsibility**:
   - Only managers can emit process_complete events
   - Managers track component acknowledgments
   - Managers determine when a process phase is complete

3. **State Machine Handling**:
   - State machine receives process_complete events
   - Validates current state before transitioning
   - Emits state change events after transition
   - Forwards state changes to all components

### State Transition Sequence
1. **Shutdown Example**:
   ```
   Power Button Press
   -> State Machine: shutdown
   -> Components: shutdown command
   -> Components: acknowledge to registry
   -> Registry: tracks acknowledgments
   -> Registry: calls shutdown callback
   -> Shutdown Manager: emits process_complete
   -> State Machine: transitions to off
   -> Components: receive state change
   ```

2. **Command Flow**:
   - Commands flow through single pathway
   - State changes are validated
   - Process completion triggers state transitions
   - State changes are forwarded to components

### Initialization Hierarchy
The system follows a strict initialization hierarchy:

1. **State Machine**:
   - Initializes first
   - Sets up command pathway
   - Initializes managers in order

2. **Managers**:
   - Power Manager: Initializes first
   - Init Manager: Initializes second, triggers component initialization
   - Test Manager: Initializes third
   - Shutdown Manager: Initializes last

3. **Components**:
   - Register with registry
   - Wait for init command
   - Acknowledge initialization
   - Begin normal operation

### Example: Initialization Flow
```typescript
// State Machine initializes managers
powerManager.init();  // First
initManager.init();   // Second
testManager.init();   // Third
shutdownManager.init(); // Last

// Init Manager starts component initialization
registry.begin(() => {
  // All components registered
  stateMachine.emit({
    type: 'process_complete',
    id: 'init',
    process: 'init'
  });
});

// Components acknowledge initialization
registry.acknowledge(componentId);
```

## Process Management and State Transitions

### Process Completion Messages

When implementing process managers (like initialization or testing):
1. **Emit Completion Messages**: Process managers should emit clear completion messages
   ```typescript
   // Example: initManager emitting completion
   stateMachine.emit({
     type: 'process_complete',
     id: 'init',
     process: 'init_complete'
   });
   ```

2. **Subscribe to Completion**: State transition manager should subscribe to these messages
   ```typescript
   // Example: stateTransitionManager handling completion
   stateMachine.subscribe((cmd: Command) => {
     if (cmd.type === 'process_complete') {
       handleProcessCompletion(cmd.process);
     }
   });
   ```

3. **Centralized Transitions**: Only the state transition manager should handle state changes
   ```typescript
   // ❌ DON'T: Process managers should not change state directly
   stateMachine.setAppState('test');
   
   // ✅ DO: Emit completion message instead
   stateMachine.emit({
     type: 'process_complete',
     id: 'init',
     process: 'init_complete'
   });
   ```

### Process Manager Responsibilities

1. **Focus on Process**:
   - Handle only their specific process
   - Don't worry about state transitions
   - Emit completion when done

2. **State Transition Manager**:
   - Central coordinator for all transitions
   - Maintains transition rules
   - Handles timing and sequencing
   - Ensures system integrity

3. **Component Integration**:
   - Components subscribe to state changes
   - Process managers coordinate their process
   - State transition manager controls flow

This pattern ensures clean separation of concerns and predictable system behavior. 

## Initialization Hierarchy

### Two-Pass Initialization Pattern

The system uses a two-pass initialization pattern to handle dependencies and ensure proper setup:

1. **First Pass - Construction Cascade**:
   - All singletons are constructed first
   - Construction cascades through dependencies
   - No initialization logic in constructors
   - Example:
     ```typescript
     // StateMachine.ts
     class StateMachine {
       constructor() {
         console.log('[StateMachine] Constructor called');
         // First pass - just construct
       }
     }

     // initManager.ts
     class InitManager {
       constructor() {
         console.log('[initManager] Constructor called');
         // First pass - just construct
       }
     }

     // registry.ts
     class RegistryManager {
       constructor() {
         console.log('[registry] Constructor called');
         // First pass - just construct
       }
     }
     ```

2. **Second Pass - Initialization Cascade**:
   - Initialization is triggered from the top level
   - Each manager initializes its dependencies before itself
   - Initialization cascades through the dependency tree
   - Example:
     ```typescript
     // StateMachine.ts
     class StateMachine {
       init() {
         // Initialize managers in order - they will cascade to their dependencies
         initManager.init();  // This will cascade to registry
         testManager.init();
       }
     }

     // initManager.ts
     class InitManager {
       init() {
         // Initialize dependencies first
         registry.init();
         // Then initialize self
         this.setupSubscriptions();
       }
     }

     // registry.ts
     class RegistryManager {
       init() {
         // Initialize self
         this.setupSubscriptions();
       }
     }
     ```

### Initialization Order

The initialization follows a strict hierarchy:

1. **StateMachine**:
   - Top-level coordinator
   - Triggers initialization cascade
   - Manages system state transitions

2. **Process Managers** (initManager, testManager):
   - Initialize their dependencies first
   - Set up their own subscriptions
   - Handle their specific processes

3. **Support Managers** (registry):
   - Initialize when needed by process managers
   - Handle specific functionality
   - Support process managers

### Manager Responsibilities

1. **StateMachine**:
   - Coordinate system state
   - Trigger initialization cascade
   - Manage state transitions

2. **Process Managers**:
   - Handle specific processes
   - Initialize their dependencies
   - Emit process completion messages

3. **Support Managers**:
   - Provide specific functionality
   - Initialize when needed
   - Support process managers

### Best Practices for Adding New Managers

1. **Construction Phase**:
   - Keep constructors minimal
   - No initialization logic
   - Just set up basic instance state

2. **Initialization Phase**:
   - Initialize dependencies first
   - Then initialize self
   - Set up subscriptions last

3. **Dependency Management**:
   - Let managers handle their own dependencies
   - Don't initialize dependencies at higher levels
   - Follow natural dependency flow

4. **Error Handling**:
   - Check initialization state
   - Prevent double initialization
   - Log initialization steps

Example of adding a new manager:
```typescript
class NewManager {
  private initialized: boolean = false;

  constructor() {
    // First pass - just construct
    console.log('[NewManager] Constructor called');
  }

  init() {
    if (this.initialized) {
      console.log('[NewManager] Already initialized');
      return;
    }

    // Initialize dependencies first
    dependencyManager.init();

    // Then initialize self
    this.setupSubscriptions();
    
    this.initialized = true;
    console.log('[NewManager] Initialization complete');
  }
}
```

This pattern ensures:
1. Clean dependency management
2. Predictable initialization order
3. Proper setup of all system components
4. Easy addition of new managers 