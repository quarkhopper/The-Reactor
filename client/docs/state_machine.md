# State Machine Documentation

## Core Principles

### Single Command Pathway
- All system communication flows through a single command pathway, analogous to an SPI bus
- The power button is a special case that controls the physical power state of the system
- No commands can be emitted before the system is powered on
- State changes are communicated through the same command pathway as all other system events

### Event Handling Best Practices
- **Avoid Emitting Events in Event Handlers**: When handling an event, avoid emitting the same type of event back to the state machine. This can create infinite loops and stack overflows.
  ```typescript
  // ❌ DON'T: This creates an infinite loop
  stateMachine.subscribe((cmd: Command) => {
    if (cmd.type === 'some_event') {
      stateMachine.emit(cmd); // Emitting same event type
    }
  });

  // ✅ DO: Just handle the event
  stateMachine.subscribe((cmd: Command) => {
    if (cmd.type === 'some_event') {
      // Handle the event without re-emitting
    }
  });
  ```

### Component ID Naming Conventions
- **Be Consistent with ID Formats**: Different components have specific ID formats that must be followed:
  - Control Rods: `control_rod_X` (where X is the rod index)
  - Fuel Rods: `fuel_rod_button_X_Y` (where X,Y are grid coordinates)
  - Load Banks: `load_bank_X` (where X is the bank index)
  - Cooling Loops: `loop_efficiency_X` (where X is the loop index)

### State Updates
- **Minimize State Updates**: Only update state when necessary and avoid redundant updates
- **Batch Related Updates**: When multiple related values change, consider batching them into a single state update
- **Validate State Changes**: Always validate incoming state changes before applying them

### Debugging Tips
- **Use Targeted Logging**: When debugging, add specific, one-time logs for state changes rather than per-tick logging
- **Log State Transitions**: Log state transitions with clear before/after values
- **Validate Event Flow**: When debugging event handling, log both the receipt and handling of events 

## Core System and UI Component Relationships

### Master-Slave Pattern
The core systems are the source of truth for all state, while UI components are slaves that reflect that state. This pattern is crucial for maintaining consistency and proper system behavior.

#### Example: Fuel Rod System
1. **Core System (Master)**:
   - Maintains the true state of each fuel rod (engaged/withdrawn/transitioning)
   - Controls timing of state transitions
   - Determines when reactivity calculations need updating
   - Emits state change events through the command pathway

2. **UI Component (Slave)**:
   - Sends simple action events through the command pathway
   - Listens for state change events from core
   - Updates visual representation based on core's state
   - Never maintains its own state about system behavior

#### Event Flow Example
```typescript
// UI Component (FuelRodButton.tsx)
const handleClick = () => {
  // Simple action event through command pathway
  stateMachine.emit({
    type: 'fuel_rod_toggle',
    id: `fuel_rod_button_${x}_${y}`
  });
};

// Core System (coreSystem.ts)
stateMachine.subscribe((cmd: Command) => {
  if (cmd.type === 'fuel_rod_toggle') {
    // Core determines new state and timing
    const newState = determineNewState(cmd.id);
    // Core emits state change through command pathway
    stateMachine.emit({
      type: 'fuel_rod_state_change',
      id: cmd.id,
      state: newState
    });
  }
});

// UI Component (FuelRodButton.tsx)
useEffect(() => {
  stateMachine.subscribe((cmd: Command) => {
    if (cmd.type === 'fuel_rod_state_change' && cmd.id === `fuel_rod_button_${x}_${y}`) {
      // Simply reflect core's state
      switch(cmd.state) {
        case 'transitioning': startBlinking(); break;
        case 'engaged': showTemperature(); break;
        case 'withdrawn': showOffState(); break;
      }
    }
  });
}, [x, y]);
```

#### Key Principles
1. **Single Source of Truth**: Core systems maintain all system state
2. **Unidirectional Flow**: 
   - UI -> Core: Simple action events through command pathway
   - Core -> UI: State change events through command pathway
3. **UI Responsibility**: 
   - Send user actions through command pathway
   - Reflect core state
   - Handle visual transitions
4. **Core Responsibility**:
   - Maintain system state
   - Control timing
   - Calculate system impacts
   - Emit state changes through command pathway

## Hardware Portability

### Physical Component Integration
The system is designed to closely align with a physical system using an SPI bus. All communication flows through a single command pathway, just as all communication in a physical system would flow through the SPI bus.

#### Input Sources
The same action events can be generated by multiple input sources, all flowing through the command pathway:
```typescript
// UI Button
const handleUiClick = (x: number, y: number) => {
  stateMachine.emit({
    type: 'fuel_rod_toggle',
    id: `fuel_rod_button_${x}_${y}`
  });
};

// Physical Button
const handlePhysicalButton = (x: number, y: number) => {
  stateMachine.emit({
    type: 'fuel_rod_toggle',
    id: `fuel_rod_button_${x}_${y}`
  });
};

// SPI Message
const handleSpiMessage = (message: SpiMessage) => {
  if (message.type === 'BUTTON_PRESS') {
    stateMachine.emit({
      type: 'fuel_rod_toggle',
      id: `fuel_rod_button_${message.x}_${message.y}`
    });
  }
};
```

### Hardware Interface Considerations

1. **Timing and Latency**:
   - Physical components may have different response times
   - Core systems should handle timing variations gracefully
   - Consider buffering for hardware communication delays

2. **Error Handling**:
   - Hardware failures should be reported but not crash the system
   - Implement fallback behaviors for hardware unavailability
   - Log hardware-specific errors separately from system errors

3. **State Synchronization**:
   - Physical components may need periodic state updates
   - Consider heartbeat mechanisms for hardware health checks
   - Implement state recovery procedures for hardware resets

### Best Practices for Hardware Integration

1. **Abstraction Layers**:
   - Keep hardware-specific code in dedicated modules
   - Use interfaces to abstract hardware details
   - Implement hardware simulators for testing

2. **Event Buffering**:
   - Buffer hardware events to handle communication delays
   - Implement priority queues for critical updates
   - Consider hardware-specific timing requirements

3. **State Management**:
   - Maintain hardware state separately from system state
   - Implement hardware state recovery procedures
   - Log hardware state changes for debugging

4. **Testing**:
   - Create hardware simulators for development
   - Implement hardware-in-the-loop testing
   - Test failure modes and recovery procedures

This architecture ensures that the system can be easily adapted to work with physical components while maintaining the same core behavior and state management. 

## Process Management and State Transitions

### Process Completion Messages

When implementing process managers (like initialization or testing):
1. **Emit Completion Messages**: Process managers should emit clear completion messages
   ```typescript
   // Example: initManager emitting completion
   stateMachine.emit({
     type: 'process_complete',
     id: 'init',
     process: 'init_complete'
   });
   ```

2. **Subscribe to Completion**: State transition manager should subscribe to these messages
   ```typescript
   // Example: stateTransitionManager handling completion
   stateMachine.subscribe((cmd: Command) => {
     if (cmd.type === 'process_complete') {
       handleProcessCompletion(cmd.process);
     }
   });
   ```

3. **Centralized Transitions**: Only the state transition manager should handle state changes
   ```typescript
   // ❌ DON'T: Process managers should not change state directly
   stateMachine.setAppState('test');
   
   // ✅ DO: Emit completion message instead
   stateMachine.emit({
     type: 'process_complete',
     id: 'init',
     process: 'init_complete'
   });
   ```

### Process Manager Responsibilities

1. **Focus on Process**:
   - Handle only their specific process
   - Don't worry about state transitions
   - Emit completion when done

2. **State Transition Manager**:
   - Central coordinator for all transitions
   - Maintains transition rules
   - Handles timing and sequencing
   - Ensures system integrity

3. **Component Integration**:
   - Components subscribe to state changes
   - Process managers coordinate their process
   - State transition manager controls flow

This pattern ensures clean separation of concerns and predictable system behavior. 