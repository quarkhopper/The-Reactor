# State Machine Documentation

## Event Handling Best Practices

### Event Loops and Infinite Recursion
- **Avoid Emitting Events in Event Handlers**: When handling an event, avoid emitting the same type of event back to the state machine. This can create infinite loops and stack overflows.
  ```typescript
  // ❌ DON'T: This creates an infinite loop
  stateMachine.subscribe((cmd: Command) => {
    if (cmd.type === 'some_event') {
      stateMachine.emit(cmd); // Emitting same event type
    }
  });

  // ✅ DO: Just handle the event
  stateMachine.subscribe((cmd: Command) => {
    if (cmd.type === 'some_event') {
      // Handle the event without re-emitting
    }
  });
  ```

### Component ID Naming Conventions
- **Be Consistent with ID Formats**: Different components have specific ID formats that must be followed:
  - Control Rods: `control_rod_X` (where X is the rod index)
  - Fuel Rods: `fuel_rod_button_X_Y` (where X,Y are grid coordinates)
  - Load Banks: `load_bank_X` (where X is the bank index)
  - Cooling Loops: `loop_efficiency_X` (where X is the loop index)

### State Updates
- **Minimize State Updates**: Only update state when necessary and avoid redundant updates
- **Batch Related Updates**: When multiple related values change, consider batching them into a single state update
- **Validate State Changes**: Always validate incoming state changes before applying them

### Debugging Tips
- **Use Targeted Logging**: When debugging, add specific, one-time logs for state changes rather than per-tick logging
- **Log State Transitions**: Log state transitions with clear before/after values
- **Validate Event Flow**: When debugging event handling, log both the receipt and handling of events 

## Core System and UI Component Relationships

### Master-Slave Pattern
The core systems are the source of truth for all state, while UI components are slaves that reflect that state. This pattern is crucial for maintaining consistency and proper system behavior.

#### Example: Fuel Rod System
1. **Core System (Master)**:
   - Maintains the true state of each fuel rod (engaged/withdrawn/transitioning)
   - Controls timing of state transitions
   - Determines when reactivity calculations need updating
   - Emits state change events that UI components must respond to

2. **UI Component (Slave)**:
   - Sends simple action events (e.g., "button pressed")
   - Listens for state change events from core
   - Updates visual representation based on core's state
   - Never maintains its own state about system behavior

#### Event Flow Example
```typescript
// UI Component (FuelRodButton.tsx)
const handleClick = () => {
  // Simple action event
  stateMachine.emit({
    type: 'fuel_rod_toggle',
    id: `fuel_rod_button_${x}_${y}`
  });
};

// Core System (coreSystem.ts)
stateMachine.subscribe((cmd: Command) => {
  if (cmd.type === 'fuel_rod_toggle') {
    // Core determines new state and timing
    const newState = determineNewState(cmd.id);
    // Core emits state change
    stateMachine.emit({
      type: 'fuel_rod_state_change',
      id: cmd.id,
      state: newState
    });
  }
});

// UI Component (FuelRodButton.tsx)
useEffect(() => {
  stateMachine.subscribe((cmd: Command) => {
    if (cmd.type === 'fuel_rod_state_change' && cmd.id === `fuel_rod_button_${x}_${y}`) {
      // Simply reflect core's state
      switch(cmd.state) {
        case 'transitioning': startBlinking(); break;
        case 'engaged': showTemperature(); break;
        case 'withdrawn': showOffState(); break;
      }
    }
  });
}, [x, y]);
```

#### Key Principles
1. **Single Source of Truth**: Core systems maintain all system state
2. **Unidirectional Flow**: 
   - UI -> Core: Simple action events
   - Core -> UI: State change events
3. **UI Responsibility**: 
   - Send user actions
   - Reflect core state
   - Handle visual transitions
4. **Core Responsibility**:
   - Maintain system state
   - Control timing
   - Calculate system impacts
   - Emit state changes

This pattern should be followed for all similar interactions between core systems and UI components. 

## Hardware Portability

### Physical Component Integration
The master-slave pattern is designed with hardware integration in mind. The core systems remain unchanged whether they're receiving input from UI components, physical controllers, or hardware interfaces.

#### Input Sources
The same action events can be generated by multiple input sources:
```typescript
// UI Button
const handleUiClick = (x: number, y: number) => {
  stateMachine.emit({
    type: 'fuel_rod_toggle',
    id: `fuel_rod_button_${x}_${y}`
  });
};

// Physical Button
const handlePhysicalButton = (x: number, y: number) => {
  stateMachine.emit({
    type: 'fuel_rod_toggle',
    id: `fuel_rod_button_${x}_${y}`
  });
};

// SPI Message
const handleSpiMessage = (message: SpiMessage) => {
  if (message.type === 'BUTTON_PRESS') {
    stateMachine.emit({
      type: 'fuel_rod_toggle',
      id: `fuel_rod_button_${message.x}_${message.y}`
    });
  }
};
```

#### Output Destinations
State change events can drive multiple output systems:
```typescript
stateMachine.subscribe((cmd: Command) => {
  if (cmd.type === 'fuel_rod_state_change') {
    // Update UI display
    updateButtonDisplay(cmd.id, cmd.state);
    
    // Update physical indicators
    updatePhysicalLed(cmd.id, cmd.state);
    
    // Control actuators
    controlActuator(cmd.id, cmd.state);
    
    // Send hardware updates
    sendHardwareUpdate(cmd.id, cmd.state);
  }
});
```

### Hardware Interface Considerations

1. **Timing and Latency**:
   - Physical components may have different response times
   - Core systems should handle timing variations gracefully
   - Consider buffering for hardware communication delays

2. **Error Handling**:
   - Hardware failures should be reported but not crash the system
   - Implement fallback behaviors for hardware unavailability
   - Log hardware-specific errors separately from system errors

3. **State Synchronization**:
   - Physical components may need periodic state updates
   - Consider heartbeat mechanisms for hardware health checks
   - Implement state recovery procedures for hardware resets

### Example: Physical Control Panel
```typescript
// Physical control panel interface
class PhysicalControlPanel {
  constructor() {
    // Initialize hardware interfaces
    this.initializeSpi();
    this.initializeGpio();
  }

  // Handle physical button presses
  handleButtonPress(x: number, y: number) {
    stateMachine.emit({
      type: 'fuel_rod_toggle',
      id: `fuel_rod_button_${x}_${y}`
    });
  }

  // Update physical indicators
  updateIndicator(x: number, y: number, state: string) {
    switch(state) {
      case 'transitioning':
        this.setLedBlinking(x, y);
        break;
      case 'engaged':
        this.setLedColor(x, y, this.getTemperatureColor(x, y));
        break;
      case 'withdrawn':
        this.setLedOff(x, y);
        break;
    }
  }
}
```

### Best Practices for Hardware Integration

1. **Abstraction Layers**:
   - Keep hardware-specific code in dedicated modules
   - Use interfaces to abstract hardware details
   - Implement hardware simulators for testing

2. **Event Buffering**:
   - Buffer hardware events to handle communication delays
   - Implement priority queues for critical updates
   - Consider hardware-specific timing requirements

3. **State Management**:
   - Maintain hardware state separately from system state
   - Implement hardware state recovery procedures
   - Log hardware state changes for debugging

4. **Testing**:
   - Create hardware simulators for development
   - Implement hardware-in-the-loop testing
   - Test failure modes and recovery procedures

This architecture ensures that the system can be easily adapted to work with physical components while maintaining the same core behavior and state management. 